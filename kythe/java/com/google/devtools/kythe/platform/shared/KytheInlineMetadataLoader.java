package com.google.devtools.kythe.platform.shared;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.google.common.base.Splitter;
import com.google.common.base.Utf8;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.flogger.FluentLogger;
import com.google.common.io.BaseEncoding;
import com.google.devtools.kythe.analyzers.base.EdgeKind;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.devtools.kythe.proto.Metadata.GeneratedCodeInfo;
import com.google.devtools.kythe.proto.Metadata.MappingRule;

/**
 * Loader that loads inline metadata from Java files generated by codegen that specify inline
 * metadata.
 *
 * <p>The metadata is added as a comment on the last line of the Java file, as a base64 encoded
 * string, which maps the Java symbols to the source language that the Java file was generated from.
 */
public final class KytheInlineMetadataLoader implements MetadataLoader {
  private static final String ANNOTATION_PREFIX = "kythe-inline-metadata:";
  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  public KytheInlineMetadataLoader() {}

  @Override
  public Metadata parseFile(String fileName, byte[] data) {
    if (!isCodegenFile(data)) {
      return null;
    }
    GeneratedCodeInfo javaMetadata;
    try {
      javaMetadata = extractMetadata(data);
    } catch (InvalidProtocolBufferException e) {
      logger.atWarning().withCause(e).log(
          "Error parsing GeneratedCodeInfo from file: %s", fileName);
      return null;
    }
    if (javaMetadata == null) {
      logger.atWarning().log("Error parsing GeneratedCodeInfo from file: %s", fileName);
      return null;
    }
    return constructMetadata(javaMetadata);
  }

  private static boolean isCodegenFile(byte[] data) {
    if (data == null || data.length < Utf8.encodedLength(ANNOTATION_PREFIX)) {
      return false;
    }
    String fileContents = new String(data, UTF_8).trim();
    if (!fileContents.contains(ANNOTATION_PREFIX)) {
      return false;
    }
    return true;
  }

  private static GeneratedCodeInfo extractMetadata(byte[] data)
      throws InvalidProtocolBufferException {
    String code = new String(data, UTF_8);
    ImmutableList<String> lines = ImmutableList.copyOf(Splitter.on('\n').splitToList(code.trim()));
    String commentPrefix = "";
    for (String line : lines) {
      if (line.contains(ANNOTATION_PREFIX)) {
        commentPrefix =
            line.substring(
                line.indexOf(ANNOTATION_PREFIX) + ANNOTATION_PREFIX.length(),
                line.lastIndexOf("\""));
        break;
      }
    }
    if (commentPrefix.isEmpty()) {
      logger.atWarning().log("Couldn't parse inline metadata");
      return null;
    }
    commentPrefix += ":";
    String lineWithMetadataComment = Iterables.getLast(lines);
    String base64EncodedData =
        lineWithMetadataComment.substring(
            lineWithMetadataComment.indexOf(commentPrefix) + commentPrefix.length());
    byte[] protoData = BaseEncoding.base64().decode(base64EncodedData);
    return GeneratedCodeInfo.parseFrom(protoData);
  }

  private static Metadata constructMetadata(GeneratedCodeInfo javaMetadata) {
    Metadata metadata = new Metadata();
    for (MappingRule mapping : javaMetadata.getMetaList()) {
      Metadata.Rule rule = new Metadata.Rule();
      rule.begin = mapping.getBegin();
      rule.end = mapping.getEnd();
      rule.vname = mapping.getVname();
      rule.edgeOut = EdgeKind.GENERATES;
      rule.reverseEdge = true;
      metadata.addRule(rule);
    }
    return metadata;
  }
}
